#!/usr/bin/env bash

# This main lib file is compliant with all versions of Bash, but is optimized for Bash 4+ with an override file for Bash 3

# Constants
__cwd="$(pwd)"
prgroot="$HOME/.clapp"
sh_assets="$prgroot/assets/bash"
js_assets="$prgroot/assets/node"
py_assets="$prgroot/assets/python"

# States
s_appname="$(echo "my_app" | tr '[:upper:]' '[:lower:]')"
s_apptype="$(cat $prgroot/.cfg | grep ^type= | cut -d '=' -f2 | tr '[:upper:]' '[:lower:]')"
s_apploc="$__cwd/${s_appname}"
__srced="${s_appname}"

# Logging and prompt functions
error() {
  printf '\e[0;1;31m[ERROR]\e[0;0;0m '"$@\n" >&2
  printf "[$(date +"%m/%d/%Y %0l:%0M:%0S")][***ERROR***] $@\n" >> "$prgroot/app.log"
}
verbose() {
  if [[ "$VERBOSE" == "true" ]]; then
    printf '\e[0;1;95m[VERBOSE]\e[0;0;0m '"$@\n"
    printf "[$(date +"%m/%d/%Y %0l:%0M:%0S")][-VERBOSE-] $@\n" >> "$prgroot/app.log"
  fi
}
log() {
  if [[ "$1" =~ ^(-f|--file|file)$ ]]; then
    shift
    printf "[$(date +"%m/%d/%Y %0l:%0M:%0S")][LOG] $@\n" >> "$prgroot/app.log"
  else
    printf '\e[0;1;36m[CLApp]\e[0;0;0m '"$@\n" | tee -a "$prgroot/app.log"
    printf "[$(date +"%m/%d/%Y %0l:%0M:%0S")][LOG] $@\n" >> "$prgroot/app.log"
  fi
}
prompt() {
  printf '\e[0;1;36m[CLApp]\e[0;0;0m '"${1}"
  read -rep ' ' yn
  yn="$(echo "$yn" | tr '[:upper:]' '[:lower:]')"
  [[ "${yn}" =~ 'y' ]] && return 0 || return 1
}

# Parse arguments
__args() {
  # Loop for command cases alongside argument parsing
  while [[ -n "$1" ]]; do
    # Arg parsing failure will force exit the program
    case $1 in
      -t | --type | type )
        shift
        [[ -n "$1" ]] && __gstype "$1" || { error "Must supply value to argument!"; exit 1; }
        ;;
      -n | --name | name )
        shift
        [[ -n "$1" ]] && __gsname "$1" || { error "Must supply value to argument!"; exit 1; }
        ;;
      -l | --location | location )
        shift
        [[ -n "$1" ]] && __gsloc "$1" || { error "Must supply value to argument!"; exit 1; }
        ;;
      -o | --options | options )
        # This should be last, otherwise the function may fail, make sure next 2 args are options
        shift
        if [[ "$1" == *"="* ]]; then
          __gsopts "$@" # Function will choose the correct one based on Bash version
        else
          error "'-o' must only be followed by options, if you want to pass other arguments, put them before '-o'!"
          exit 1
        fi
        ;;
      -C | --config | config )
        shift
        [[ -n "$1" ]] && __gscfg "$@" || { error "Must supply config option to get/set or 'list'!"; exit 1; }
        return 0;;
      # Singletons
      --reset-cfg | reset-cfg )
        echo "Resetting CLApp to default configuration..."
        cp -rf "$(find $HOME -type d -name clapp)"/.clapp "$HOME" && echo "CLApp's config has been reset!" || echo "Failed to reset defaults!"
        exit 0;;
      -L | --logs | logs )
        cat "$prgroot/app.log"
        exit 0;;
      -X | --clear-logs | clear-logs )
        echo -n "" > "$prgroot/app.log"
        log "Logs cleared!"
        exit 0;;
      -\? | -h | --help | help )
        cat "$prgroot/help"
        exit 0;;
      -v | --version | version )
        cat "$prgroot/version"
        exit 0;;
      --update | update )
        # Clapp does this by default, this ensures clapp doesn't continue execution
        [[ $(diff "$HOME/bin/clapp" "$(find $HOME -type d -name clapp)/clapp") ]] || log "CLApp up to date!"
        exit 0;;
      --docs | docs )
        shift
        local sys="$(uname -s)"
        if [[ "$sys" == "Darwin" ]]; then
          open "$prgroot/docs/index.html"
        elif [[ "$sys" == "Linux" ]]; then
          [[ -n "$(command -v xdg-open)" ]] && xdg-open "$prgroot/docs/index.html" 2>/dev/null || { error "Command to open docs in browser not found!"; exit 1; }
        elif [[ "$sys" == "MINGW"* ]]; then
          start "$prgroot/docs/index.html"
        else
          error "OS not supported for opening documentation!"
        fi
        exit 0;;
      -V | --verbose | verbose )
        VERBOSE=true;;
      * )
        error "Option '$1' not found!"
        exit 1;;
    esac
    shift
  done
  verbose "Type: $(__gstype)"
  verbose "Name: $(__gsname)"
  verbose "Path: $(__gsloc)"
}

# Function to parse the config file
__gscfg() {
  local cfg="$prgroot/.cfg"
  rwrite() {
    verbose "Setting $rule"
    sed -i -e "s/$rule=$oldvalue/$rule=$newvalue/" "$cfg"
    log "Updated rule $rule from $oldvalue to $newvalue!"
  }
  while [[ $1 ]]; do
    if [[ $1 =~ '=' ]]; then
      local rule="$(echo "$1" | cut -d '=' -f1)"
      local oldvalue="$(cat "$cfg" | grep "$rule" | cut -d '=' -f2)"
      local newvalue="$(echo "$1" | cut -d '=' -f2 | tr '[:upper:]' '[:lower:]')"
      local types="$([[ "${BASH_VERSINFO[0]}" -ge 4 ]] && echo "${lists[types]}" || echo "$types")"
      case "$rule" in
        type )
          if [[ ! "${newvalue}" =~ $types ]]; then
            error "Type value must be Bash, Node, or Python!"
          else
            rwrite
          fi
          ;;
        * )
          rwrite
          ;;
      esac
    elif [[ "$1" == 'list' ]]; then
      log "Current Settings:"
      cat $cfg
      return
    elif [[ "$1" == 'RESET' ]]; then
      __args --reset-cfg
      return
    else
      log "Rule: `cat "$cfg" | grep ^"$1"$ || echo "No Rule Found!"`"
    fi
  shift; done
}

# Getter/Setters for non-list states (full compatibility)
__gstype() {
  if [ -z "$1" ]; then
    echo "$s_apptype"
  else
    s_apptype="$1"
  fi
}
__gsname() {
  if [ -z "$1" ]; then
    echo "$s_appname"
  else
    s_appname="$(echo "$1" | tr '[:upper:]' '[:lower:]')"
    s_apploc="$(pwd)/$s_appname"
  fi
}
__gsloc() {
  if [ -z "$1" ]; then
    echo "$s_apploc"
  else
    s_apploc="$1/$(echo "$s_appname" | tr '[:upper:]' '[:lower:]')"
  fi
}

# Load optimized lib based on current Bash version
if [[ "${BASH_VERSINFO[0]}" -ge 4 ]]; then
  log file "Loading Bash 4+ optimized lib..."
  source "$prgroot/postbash4.lib"
else
  log file "Loading Pre Bash 4+ optimized lib..."
  source "$prgroot/prebash4.lib"
fi
