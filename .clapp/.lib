#!/bin/bash

# Funcs and vars
prgroot="$HOME/.clapp"
s_appname="my_app"
s_apptype="sh"
s_apploc="`pwd`/${s_appname,,}"
__srced="${s_appname,,}"
declare -A s_appopts
__cwd=`pwd`
__errtxt='echo -e ''\e[0;1;31m[ERROR]\e[0;0;0m '
__systxt='echo -e ''\e[0;1;36m[CLApp]\e[0;0;0m '
__devtxt='echo -e ''\e[0;1;95m[CLAppDev]\e[0;0;0m '
declare -A pyfiles
declare -A jsfiles
declare -A shfiles

__loadcfg() {
  local cfg="$prgroot/.cfg"
}
# Config vars will be set via function in-case of needing reloaded
__loadcfg

# Getter/Setters for states
__gstype() {
  if [ -z "$1" ]; then
    echo "$s_apptype"
  else
    s_apptype="$1"
  fi
}
__gsname() {
  if [ -z "$1" ]; then
    echo "$s_appname"
  else
    s_appname="$1"
    s_apploc="`pwd`/${s_appname,,}"
  fi
}
__gsloc() {
  if [ -z "$1" ]; then
    echo "$s_apploc"
  else
    s_apploc="$1/${s_appname,,}"
  fi
}
__gsopts() {
  if [ -z "$1" ]; then
    for key in "${!s_appopts[@]}"; do
        echo "$key: ${s_appopts[$key]}"
    done
  else
    for arg in $@; do
      local option="`echo "$arg" | cut -d '=' -f1`"
      local value="`echo "$arg" | cut -d '=' -f2`"

      if [[ "$option" == "name" ]]; then
        s_appname="$value"
      elif [[ "$option" == "type" ]]; then
        s_apptype="$value"
      elif [[ "$option" == "location" ]]; then
        s_apploc="$value"
      else
        s_appopts[$option]="$value"
      fi
    done
  fi
}

# Functionality
__mknode() {
  [[ `command -v npm || command -v node` ]] || ( $__errtxt"NodeJS Not Installed!" && exit )
  __opts # Process general options

  # Process Node-specific options
  # web: process string to respective packages
  # Slot 1: Mongo (M), MySQL (S), MS-SQL (s), PostgreSQL (P), None (N)
  # Slot 2: Express (E), Node (N)
  # Slot 3: React (R), Angular (A), EJS (E), Jade (J), HTML (H)
  local pkginstallstr="" # Dynamically built to ensure project setup is handled by node and not by clapp
  local viewext=".html"
  procstr() {
    local db="${1:0:1}"
    local proc="${1:1:1}"
    local tmpeng="${1:2:1}"
    [ $__DEV ] && $__devtxt"db: $db"
    [ $__DEV ] && $__devtxt"proc: $proc"
    [ $__DEV ] && $__devtxt"tmpeng: $tmpeng"
    case $db in
      M )
        pkginstallstr="${pkginstallstr}mongoose "
        ;;
      S | P | s )
        pkginstallstr="${pkginstallstr}sequelize "
        ;;
    esac
    case $proc in
      E )
        pkginstallstr="${pkginstallstr}express cookie-parser "
        ;;
    esac
    case $tmpeng in
      R )
        [ "$proc" = "E" ] && pkginstallstr="${pkginstallstr}react express-react-views " || pkginstallstr="${pkginstallstr}react "
        viewext=".jsx"
        ;;
      A )
        pkginstallstr="${pkginstallstr}angular "
        ;;
      E )
        pkginstallstr="${pkginstallstr}ejs "
        viewext=".ejs"
        ;;
      J )
        pkginstallstr="${pkginstallstr}jade "
        viewext=".jade"
        ;;
    esac
  }
  procstr "${s_appopts[style]}"
  [ ! -z "$pkginstallstr" ] && pkginstallstr="npm i $pkginstallstr"

  # Begin setup of node project directory
  cd "$s_apploc"
  echo -e "#!/bin/env node" >> index.js
  npm init -y >>/dev/null
  [ ! -z "$pkginstallstr" ] && echo "Installing packages..." && ( $pkginstallstr )>>/dev/null && echo "Packages installed!"
}
__mkpy() {
  [[ `command -v python || command -v python3` ]] && $__errtxt"Python Not Installed!" && exit
  __opts

  local main=`cat <<-MAIN
#!/bin/env python

# $s_appname - Does things and stuff
MAIN
  `
  touch "$s_apploc/version"
  touch "$s_apploc/help"
  echo -e "$main" >> "$s_apploc/$s_appname.py"
  chmod u+x "$s_apploc/$s_appname"

  # If we got here, we succeeded
  $__systxt"Successfully made app $s_appname in location $s_apploc!"
  $__systxt"Refer to documentation in clapp (clapp --docs) on further setup!"
}
__mksh() {
  __opts # Process app options and properties
  
  local libfile=`cat <<-LIB
# $s_appname's Functions and Variables

# Vars
__cwd=\\\`pwd\\\`
prgroot="\\\$HOME/.${s_appname,,}"

# Config
__loadcfg() {
  local cfg="\\\$prgroot/.cfg"
  editor=\\\`cat \\\$cfg | grep 'editor' | cut -d '=' -f2\\\`
  defaulttype=\\\`cat \\\$cfg | grep 'defaulttype' | cut -d '=' -f2\\\`
}
# Config vars will be set via function in-case of needing reloaded
__loadcfg

# Funcs
__args() {
  # Process args
  while [[ "\\\$1" =~ '-' ]]; do
    # ALL CASE STATEMENT OPTIONS SHOULD END WITH 'exit;;' in this function!!
    case "\\\$1" in
      -h | --help )
        cat \\\$prgroot/help
        exit;;
      -v | --version )
        cat \\\$prgroot/version
        exit;;
      * ) # Catch-all
        cat \\\$prgroot/help | head -1
        echo "\\"\\\$1\\" is not an argument!"
        exit;;
    esac
  shift; done
}
LIB
  `
  local appfile=`cat <<-APP
# $s_appname's main code

autoupdate=\\\`cat \\\$HOME/.${s_appname,,}/.cfg | grep 'autoup' | cut -d '=' -f2\\\`
repo=\\\`find \\\$HOME -type d -name $__srced\\\`

# Check for unit test
if [ \\\$${s_appname^^}_TST ]; then
  # Load the lib from the repo and set prgroot to repo
  echo -e "[${s_appname^^}] UNIT TEST MODE! READING FROM REPO!"
  source \\\$repo/.${s_appname,,}/.lib
  prgroot="\\\$repo/.${s_appname,,}"
elif [[ \\\$autoupdate ]]; then
  # Check for updates
  [ ! -d \\\$HOME/.${s_appname,,} ] && \\\$repo/install
  if [[ \\\`diff \\\$repo/.${s_appname,,} \\\$HOME/.${s_appname,,}\\\` ]]; then echo "Updating ${s_appname,,}..."; \\\$repo/install; fi
  
  # Load lib
  source \\\$HOME/.${s_appname,,}/.lib
else
  source \\\$HOME/.${s_appname,,}/.lib
fi


__${s_appname,,}() {
  [ -z "$1" ] && __args -h || __args \\\$@
  # Write your app's main flow here (General stub supports arg handling)
}

__${s_appname,,} \\\$@

# Cleanup for accidental sourcing
unset __${s_appname,,} __args __cwd autoupdate repo
APP
  `
  local installfile=`cat <<-INS
#!/bin/bash

# $s_appname's installer
install() {
  local repo=\\\$(find \\\$HOME -type d -name $__srced)
  cp \\\$repo/${s_appname,,} \\\$HOME/bin || return false
  cp -r \\\$repo/.${s_appname,,} \\\$HOME || return false
  echo "$s_appname installed!"
}

install || echo "Install failed!"
INS
  `
  # Generate based on all-in-one
  if [ ${s_appopts[allone]} ]; then
    echo -e "#!/bin/bash\n\nversion=\"${s_appname} - v1.0.0\"\nhelp=\"\"\n\n$libfile\n$appfile\nunset version help" >> "$s_apploc/${s_appname,,}"
    chmod u+x "$s_apploc/${s_appname,,}"
  else
    mkdir "$s_apploc/.${s_appname,,}"
    echo "${s_appname} - v1.0.0" >> "$s_apploc/.${s_appname,,}/version"
    echo "Usage: ${s_appname,,} [options] <args>" >> "$s_apploc/.${s_appname,,}/help"
    echo -e "#!/bin/bash\n\n$libfile" >> "$s_apploc/.${s_appname,,}/.lib"
    echo -e "#!/bin/bash\n\n$appfile" >> "$s_apploc/${s_appname,,}"
    chmod u+x "$s_apploc/.${s_appname,,}/.lib"
    chmod u+x "$s_apploc/${s_appname,,}"
  fi

  # Generate install file
  echo "$installfile" >> "$s_apploc/install"
  chmod u+x "$s_apploc/install"

  # If we got here, we succeeded
  $__systxt"Successfully made app $s_appname in location $s_apploc!"
  $__systxt"Refer to documentation in clapp (clapp --docs) on further setup!"
}

# Parsing
# Options take precedence over arguments
# Setting name, type, or location in options will override
__opts() {
  # Begin generating folders and files
  [ -d "$s_apploc" ] && $__errtxt"App with that name already exists!" && exit

  __srced=`[ ${s_appopts[src]} ] && echo ${s_appname,,}/src || echo ${s_appname,,}`
  $__systxt"Generating $s_appname in location $s_apploc..."
  [ $__DEV ] && ( $__devtxt"Options: "; __gsopts )
  mkdir "$s_apploc"

  # Parse general options
  for key in "${!s_appopts[@]}"; do
    case $key in
      # Boolean
      src )
        mkdir "$s_apploc/src"
        s_apploc="$s_apploc/src"
        ;;
      repo )
        cd "$s_apploc" && git init >>/dev/null && echo "# $s_appname" >> readme.md
        $__systxt"Initialized app as repo! Don't forget to run \`git commit -a -m \"Creation of $s_appname!\"\`"
        cd $s_usercwd
        ;;
    esac
  done
}
__args() {
  while [[ "$1" =~ "-" ]]; do
    # Arg parsing failure will force exit the program
    case $1 in
      -t | --type )
        shift
        # [ __DEV ] && $__devtxt"Setting app type to $1"
        [ ! -z "$1" ] && __gstype "$1" || ( $__errtxt"Must supply value to argument!"; exit )
        ;;
      -n | --name )
        shift
        # [ __DEV ] && $__devtxt"Setting app name to $1"
        [ ! -z "$1" ] && __gsname "$1" || ( $__errtxt"Must supply value to argument!"; exit )
        ;;
      -l | --location )
        shift
        # [ __DEV ] && $__devtxt"Setting app location to $1"
        [ ! -z "$1" ] && __gsloc "$1" || ( $__errtxt"Must supply value to argument!"; exit )
        ;;
      -o | --options )
        # This should be last, otherwise the function may fail, make sure next 2 args are options
        shift;
        # echo "$@"
        if [[ "$1" =~ "=" ]]; then
          __gsopts "$@"
        else
          $__errtxt"'-o' must only be followed by options, if you want to pass other arguments, put them before '-o'!"
          exit
        fi
        ;;
      -h | --help )
        echo "`cat $HOME/.clapp/help`"
        exit;;
      -v | --version )
        echo "`cat $HOME/.clapp/version`"
        exit;;
      -u | --update )
        # Clapp does this by default, this ensures clapp doesn't continue execution
        [[ `diff $HOME/bin/clapp $(find $HOME -type d -name clapp)/clapp` ]] || $__systxt"CLApp up to date!"
        exit;;
      # --docs )
      #   ;;
      -V | --verbose )
        __DEV=true
        ;;
      * )
        $__errtxt"Option '$1' not found!"
        exit;;
    esac
    shift
  done;
  [ $__DEV ] && $__devtxt"Type: `__gstype`"
  [ $__DEV ] && $__devtxt"Name: `__gsname`"
  [ $__DEV ] && $__devtxt"Path: `__gsloc`"
}