#!/bin/bash

# Funcs and vars
prgroot="$HOME/.clapp"
sh_assets="$prgroot/assets/bash"
js_assets="$prgroot/assets/node"
py_assets="$prgroot/assets/python"
s_appname="my_app"
s_apptype="$(cat $prgroot/.cfg | grep ^type= | cut -d '=' -f2)"
s_apploc="$PWD/${s_appname,,}"
__srced="${s_appname,,}"
declare -A s_appopts
declare -A v_lists # Setup for bash clapp apps
lists[types]="^(bash|sh|py|python|node|js|javascript)$"
__cwd=`pwd`

error() {echo -e '\e[0;1;31m[ERROR]\e[0;0;0m '"${1}" &>2;}
verbose() {[[ "$__DEV" == "true" ]] && echo -e '\e[0;1;95m[CLAppDev]\e[0;0;0m '"${1}";}
log() {echo -e '\e[0;1;36m[CLApp]\e[0;0;0m '"${1}";}

# Getter/Setters for states
__gstype() {
  if [ -z "$1" ]; then
    echo "$s_apptype"
  else
    s_apptype="$1"
  fi
}
__gsname() {
  if [ -z "$1" ]; then
    echo "$s_appname"
  else
    s_appname="$1"
    s_apploc="`pwd`/${s_appname,,}"
  fi
}
__gsloc() {
  if [ -z "$1" ]; then
    echo "$s_apploc"
  else
    s_apploc="$1/${s_appname,,}"
  fi
}
__gsopts() {
  if [ -z "$1" ]; then
    for key in "${!s_appopts[@]}"; do
        echo "$key: ${s_appopts[$key]}"
    done
  else
    for arg in $@; do
      local option="`echo "$arg" | cut -d '=' -f1`"
      local value="`echo "$arg" | cut -d '=' -f2`"
      verbose "Option: $option"
      verbose "Value: $value"

      if [[ "$option" == "name" ]]; then
        s_appname="$value"
      elif [[ "$option" == "type" ]]; then
        s_apptype="$value"
      elif [[ "$option" == "location" ]]; then
        s_apploc="$value"
      else
        s_appopts[$option]="$value"
      fi
    done
  fi
}
__gscfg() {
  rwrite() {
    verbose "Setting $rule"
    sed -i -e "s/$rule=$oldvalue/$rule=$newvalue/" $cfg
    log "Updated rule $rule from $oldvalue to $newvalue!"
  }
  local cfg="$prgroot/.cfg"
  while [[ $1 ]]; do
    if [[ $1 =~ '=' ]]; then
      local rule="`echo "$1" | cut -d '=' -f1`"
      local oldvalue="`cat $cfg | grep "$rule" | cut -d '=' -f2`"
      local newvalue="`echo "$1" | cut -d '=' -f2`"
      case "$rule" in
        type )
          if [[ ! "${newvalue,,}" =~ ${lists[types]} ]]; then
            error "Type value must be Bash, Node, or Python!"
          else
            rwrite
          fi
          ;;
        * )
          rwrite
          ;;
      esac
    elif [[ $1 == 'list' ]]; then
      log "Current Settings:"
      cat $cfg
      return
    elif [[ $1 == 'RESET' ]]; then
      __args --reset-cfg
      return
    else
      log "Rule: `cat $cfg | grep "\b$1\b" || echo "No Rule Found!"`"
    fi
  shift; done
}

# Functionality
__mknode() {
  [[ `command -v npm || command -v node` ]] || ( error "NodeJS Not Installed!" && exit )
  __opts # Process general options

  # Process Node-specific options
  # web: process string to respective packages
  # Slot 1: Mongo (M), MySQL (S), MS-SQL (s), PostgreSQL (P), None (N)
  # Slot 2: Express (E), Node (N)
  # Slot 3: React (R), Angular (A), EJS (E), Jade (J), HTML (H)
  local pkginstallstr="" # Dynamically built to ensure project setup is handled by node and not by clapp
  local viewext=".html"
  procstr() {
    local db="${1:0:1}"
    local proc="${1:1:1}"
    local tmpeng="${1:2:1}"
    verbose "db: $db"
    verbose "proc: $proc"
    verbose "tmpeng: $tmpeng"
    case $db in
      M )
        pkginstallstr="${pkginstallstr}mongoose "
        ;;
      S | P | s )
        pkginstallstr="${pkginstallstr}sequelize "
        ;;
    esac
    case $proc in
      E )
        pkginstallstr="${pkginstallstr}express cookie-parser "
        ;;
    esac
    case $tmpeng in
      R )
        [ "$proc" = "E" ] && pkginstallstr="${pkginstallstr}react express-react-views " || pkginstallstr="${pkginstallstr}react "
        viewext=".jsx"
        ;;
      A )
        pkginstallstr="${pkginstallstr}angular "
        ;;
      E )
        pkginstallstr="${pkginstallstr}ejs "
        viewext=".ejs"
        ;;
      J )
        pkginstallstr="${pkginstallstr}jade "
        viewext=".jade"
        ;;
    esac
  }
  procstr "${s_appopts[style]}"

  # Begin setup of node project directory
  cd "$s_apploc"
  echo -e "#!/bin/env node\n\n$__JSAPP" >> index.js
  npm init -y >>/dev/null
  [ ! -z "$pkginstallstr" ] && echo "Installing packages..." && ( npm i $pkginstallstr )>>/dev/null && echo "Packages installed!"
}
__mkpy() {
  if [[ ! `command -v python` && ! `command -v python3` ]]; then error "Python Not Installed!"; exit; fi
  __opts

  source "$py_assets/main.hdf" # __PYAPP
  touch "$s_apploc/version"
  touch "$s_apploc/help"
  echo -e "$__PYAPP" >> "$s_apploc/$s_appname.py"
  chmod u+x "$s_apploc/$s_appname.py"

  # If we got here, we succeeded
  log "Successfully made app $s_appname in location $s_apploc!"
  log "Refer to documentation in clapp (clapp --docs) on further setup!"
}
__mksh() {
  # Process app options and properties
  __opts
  [ ${s_appopts[altargfunc]} ] && __ALT=true
  [ ${s_appopts[commands]} ] && __CMD=true

  # Pull HDFs (__SHINSTALL, __SHAPP, __SHLIB)
  source "$sh_assets/install.hdf"
  source "$sh_assets/main.hdf"
  source "$sh_assets/lib.hdf"
  # Generate based on all-in-one
  if [ ${s_appopts[allone]} ]; then
    echo -e "#!/bin/bash\n\nversion=\"${s_appname} - v1.0.0\"\nhelp=\"\"\n\n$__SHLIB\n$__SHAPP\nunset version help" >> "$s_apploc/${s_appname,,}"
    chmod u+x "$s_apploc/${s_appname,,}"
  else
    mkdir "$s_apploc/.${s_appname,,}"
    echo "${s_appname} - v1.0.0" >> "$s_apploc/.${s_appname,,}/version"
    echo "Usage: ${s_appname,,} [options] <args>" >> "$s_apploc/.${s_appname,,}/help"
    echo -e "#!/bin/bash\n\n$__SHLIB" >> "$s_apploc/.${s_appname,,}/.lib"
    echo -e "#!/bin/bash\n\n$__SHAPP" >> "$s_apploc/${s_appname,,}"
    chmod u+x "$s_apploc/.${s_appname,,}/.lib"
    chmod u+x "$s_apploc/${s_appname,,}"
  fi

  # Generate install file
  echo "$__SHINSTALL" >> "$s_apploc/install"
  chmod u+x "$s_apploc/install"

  # If we got here, we succeeded
  log "Successfully made app $s_appname in location $s_apploc!"
  log "Refer to documentation in clapp (clapp --docs) on further setup!"
}

# Parsing
# Options take precedence over arguments
# Setting name, type, or location in options will override
__opts() {
  # Begin generating folders and files
  [ -d "$s_apploc" ] && error "App with that name already exists!" && exit

  __srced=`[ ${s_appopts[src]} ] && echo ${s_appname,,}/src || echo ${s_appname,,}`
  log "Generating $s_appname in location $s_apploc..."
  [ $__DEV ] && ( $__devtxt"Options: "; __gsopts )
  mkdir "$s_apploc"

  # Parse general options
  for key in "${!s_appopts[@]}"; do
    case $key in
      # Boolean
      src )
        mkdir "$s_apploc/src"
        s_apploc="$s_apploc/src"
        ;;
      repo )
        cd "$s_apploc" && git init >>/dev/null && echo "# $s_appname" >> readme.md
        log "Initialized app as repo! Don't forget to run \`git commit -a -m \"Creation of $s_appname!\"\`"
        cd $s_usercwd
        ;;
    esac
  done
}
__args() {
  while [[ "$1" =~ "-" ]]; do
    # Arg parsing failure will force exit the program
    case $1 in
      -t | --type )
        shift
        verbose "Setting app type to $1"
        [ ! -z "$1" ] && __gstype "$1" || ( error "Must supply value to argument!"; exit )
        ;;
      -n | --name )
        shift
        verbose "Setting app name to $1"
        [ ! -z "$1" ] && __gsname "$1" || ( error "Must supply value to argument!"; exit )
        ;;
      -l | --location )
        shift
        verbose "Setting app location to $1"
        [ ! -z "$1" ] && __gsloc "$1" || ( error "Must supply value to argument!"; exit )
        ;;
      -o | --options )
        # This should be last, otherwise the function may fail, make sure next 2 args are options
        shift
        if [[ "$1" =~ "=" ]]; then
          __gsopts "$@"
        else
          error "'-o' must only be followed by options, if you want to pass other arguments, put them before '-o'!"
          exit
        fi
        ;;
      -C | --config )
        shift
        [ ! -z "$1" ] && __gscfg "$@" || ( error "Must supply config option to get/set or 'list'!"; exit )
        exit;;
      --reset-cfg )
        echo "Resetting CLApp to default configuration..."
        cp -rf $(find $HOME -type d -name clapp)/.clapp $HOME && echo "CLApp's config has been reset!" || echo "Failed to reset defaults!"
        exit;;
      -\? | -h | --help )
        echo "`cat $HOME/.clapp/help`"
        exit;;
      -v | --version )
        echo "`cat $HOME/.clapp/version`"
        exit;;
      -u | --update )
        # Clapp does this by default, this ensures clapp doesn't continue execution
        [[ `diff $HOME/bin/clapp $(find $HOME -type d -name clapp)/clapp` ]] || log "CLApp up to date!"
        exit;;
      --docs )
        shift
        local sys=`uname -a`
        if [[ $sys =~ 'MINGW' || $sys =~ 'WSL' ]]; then
          ( "`find "$([[ "$sys" =~ 'WSL' ]] && echo "/mnt")""/c/Program Files (x86)/" -type f -name msedge.exe 2>/dev/null | head -1`" $prgroot/docs/index.html & )
        fi
        exit;;
      -V | --verbose )
        __DEV=true
        ;;
      * )
        error "Option '$1' not found!"
        exit;;
    esac
    shift
  done;
  verbose "Type: `__gstype`"
  verbose "Name: `__gsname`"
  verbose "Path: `__gsloc`"
}
__quick() {
  # CLApp's shorthand style
  # clapp <name> <type> [location] [options...]
  local name="$1"; shift
  local type="${s_apptype,,}"
  local loc=""
  local opts=""

  while [[ -n "$1" ]]; do
    if [[ "$1" =~ ${lists[types]} ]]; then
      type="$1"
    elif [[ "$1" =~ '/' ]]; then
      loc="$1"
    elif [[ "$1" =~ '=' ]]; then
      opts="$1"
      while [[ "$1" =~ '=' ]]; do
        opts="$opts $1"
      shift; done
    fi
  shift; done

  if [[ -n "$opts" ]]; then
    __gsname "$name" &>/dev/null
    __gstype "$type" &>/dev/null
    __gsloc "$loc" &>/dev/null
    __gsopts "${opts}" &>/dev/null
  else
    __gsname "$name" &>/dev/null
    __gstype "$type" &>/dev/null
    __gsopts "${loc}" &>/dev/null
  fi
}