#!/bin/bash
# SOURCE THIS FILE FOR HEREDOC INTERPOLATION

# Normal
__FRONT=`cat << LIB
# $s_appname's Functions and Variables

# Vars
__cwd=\\\$(pwd)
prgroot="\\\$HOME/.${s_appname,,}"

declare -A lists # For any lists your app may need as reference

# Config
__loadcfg() {
	local cfg="\\\$prgroot/.cfg"
	# Write config variables below like so: name=\\\$(cat "\\\$cfg" | grep 'name' | cut -d '=' -f2)
}
# Config vars will be set via function in-case of needing reloaded
__loadcfg

# Funcs
__cfg() {
	local cfg="\\\$prgroot/.cfg"
	while [[ -n "\\\$1" ]]; do
		if [[ "\\\$1" =~ '=' ]]; then
			local rule="\\\$(echo "\\\$1" | cut -d '=' -f1)"
			local oldvalue="\\\$(cat "\\\$cfg" | grep "\\\$rule" | cut -d '=' -f2)"
			local newvalue="\\\$(echo "\\\$1" | cut -d '=' -f2)"
			sed -i -e "s/\\\$rule=\\\$oldvalue/\\\$rule=\\\$newvalue/" "\\\$cfg"
			echo "Updated rule \\\$rule from \\\$oldvalue to \\\$newvalue!"
		elif [[ "\\\$1" == 'list' ]]; then
			echo "Current Settings:"
			cat "\\\$cfg"
			return
		elif [[ "\\\$1" == 'RESET' ]]; then
			__args --reset-cfg
		fi
		echo "Rule: \\\$(cat "\\\$cfg" | grep "\\\\b\\\$1\\\\b" || echo "No Rule Found!")"
	shift; done
}
LIB
`
__ARGFUNC=`cat << ARG
__args() {
	# Process args
	while [[ "\\\$1" =~ '-' ]]; do
		# End case statements with 'exit;;' to ensure program only runs that argument
		# Otherwise use 'exit;;' when you want to bail out due to erroneous behaviour
		case "\\\$1" in
			-C | --config )
				shift
				[ ! -z "\\\$1" ] && __cfg "\\\$@" || ( error "Must supply rule or 'list'!"; exit )
				exit;;
			--reset-cfg )
				echo "Resetting ${s_appname} to default configuration..."
				cp -rf \\\$(find \\\$HOME -type d -name ${s_appname,,})/.${s_appname,,} \\\$HOME && echo "${s_appname}'s config has been reset!" || echo "Failed to reset defaults!"
				exit;;
			-\\? | -h | --help )
				cat \\\$prgroot/help
				exit;;
			-v | --version )
				cat \\\$prgroot/version
				exit;;
			-V | --verbose )
				VERBOSE=true
				;;
			* ) # Catch-all
				cat \\\$prgroot/help | head -1
				echo "\\"\\\$1\\" is not an argument!"
				exit;;
		esac
	shift; done
}
ARG
`
__ALTFUNC=`cat << ALT
__args() {
	# Process args
	while [[ "\\\$1" =~ '-' ]]; do
		# End case statements with 'return;;' to allow for arglist to be passed around and continue execution
		# Otherwise use 'exit;;' when you want to bail out due to erroneous behaviour
		# Each statement should look like this:
		# <ARG> | <ALTARGVERSION> ); shift
		#   DATA VALIDATION
		#   <FUNC> "\\\$@"
		#   return;;
		case "\\\$1" in
			-C | --config )
				shift; [ ! -z "\\\$1" ] && __cfg "\\\$@" || ( error "Must supply rule or 'list'!"; exit )
				return;; # So the function doesn't endlessly recurse
			--reset-cfg )
				echo "Resetting ${s_appname} to default configuration..."
				cp -rf \\\$(find \\\$HOME -type d -name ${s_appname,,})/.${s_appname,,} \\\$HOME && echo "${s_appname}'s config has been reset!" || echo "Failed to reset defaults!"
				exit;;
			-\\? | -h | --help )
				cat "\\\$prgroot/help"
				exit;;
			-v | --version )
				cat "\\\$prgroot/version"
				exit;;
			-V | --verbose )
				VERBOSE=true
				;;
			* ) # Catch-all
				cat "\\\$prgroot/help" | head -1
				echo "\\"\\\$1\\" is not an argument!"
				exit;;
		esac
	shift; done
}
ALT
`
__CMDFUNC=`cat << CMD
lists[cmd]="^(config|help|version)$" # To be tested against
__cmds() {
	# Process commands
	# Adjust the args command accordingly if desired
	while [[ true ]]; do
		# End case statements with 'exit;;' to run just the one command
		# Otherwise use 'exit;;' when you want to bail out due to erroneous behaviour
		case "\\\${1,,}" in
			config )
				shift; [ ! -z "\\\$1" ] && __cfg "\\\$@" || ( error "Must supply rule or 'list'!"; exit )
				return;; # So the function doesn't endlessly recurse
			help )
				cat "\\\$prgroot/help"
				exit;;
			version )
				cat "\\\$prgroot/version"
				exit;;
			* ) # Catch-all
				cat "\\\$prgroot/help" | head -1
				echo "\\"\\\$1\\" is not an argument!"
				exit;;
		esac
	shift; done
}
CMD
`
__BACK=`cat << BAK
error() { echo -e '\e[0;1;31m[ERROR]\e[0;0;0m '"\\\$msg" >&2; }
verbose() { [[ \\\$VERBOSE ]] && echo -e '\e[0;1;35m[VERBOSE]\e[0;0;0m '"\\\$msg"; }
log() { echo -e '\e[0;1;32m[${s_appname^^}]\e[0;0;0m '"\\\$msg"; }
BAK
`

__SHLIB="${__FRONT}\n$([[ $__ALT ]] && echo "$__ALTFUNC" || echo "$__ARGFUNC")\n\n$([[ $__CMD ]] && echo "$__CMDFUNC\n")${__BACK}"
# EOF